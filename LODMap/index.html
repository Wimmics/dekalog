<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin=""/>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.3"></script>
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <script type="text/javascript" src="./index.js"></script>

    <title>KartoGraphI: Knowledge graph cartography and index</title>
</head>
<body>
    <div class="container">
        <div class="row justify-content-center">
            <div class="col">
                <div class="container">Geolocation of the indexed endpoint</div>
                <div class="container border" id="map"></div>
            </div>
            <div class="col">
                <div class="container"> Size of the indexed bases</div>
                <div class="container border" id="histo"></div>
            </div>
            <div class="col">
                <div class="container"> Size of the indexed bases</div>
                <div class="container border" id="sizes"></div>
            </div>
            <div class="col">
                <div class="row">Graph of the bases connected to their vocabularies*</div>
                <div class="container border" id="vocabs"></div>
                <div class="row">*: Only the vocabularies listed in LOV are displayed.</div>
            </div>
        </div>
    </div>
    <script src="file:///home/pmaillot/git/dekalog/LODMap/sparql_sparqlEndpoint_list_result.js"></script>
    <script>
    // Initialization of the map
    var map = L.map('map').setView([24.5271348225978, 62.22656250000001], 2);
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFpbGxwaWVycmUiLCJhIjoiY2t5OXlxeXhkMDBlZDJwcWxpZTF4ZGkxZiJ9.dCeJEhUs7EF2HI50vdv-7Q', {
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>',
        maxZoom: 18,
        id: 'mapbox/streets-v11',
        tileSize: 512,
        zoomOffset: -1,
        accessToken: 'pk.eyJ1IjoibWFpbGxwaWVycmUiLCJhIjoiY2t5OXlxeXhkMDBlZDJwcWxpZTF4ZGkxZiJ9.dCeJEhUs7EF2HI50vdv-7Q'
    }).addTo(map);

    function sparqlQueryJSON(query, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                var response = JSON.parse(this.responseText);
                callback(response);
            }
        }
        xhr.open('GET', 'http://prod-dekalog.inria.fr/sparql?query='+encodeURIComponent(query)+"&format=json", true);
        xhr.send();
    };

    function intersection(setA, setB) {
        var intersection = new Set();
        for (var elem of setB) {
            if (setA.has(elem)) {
                intersection.add(elem);
            }
        }
        return intersection;
    }

    function haveIntersection(setA, setB) {
        return intersection(setA, setB).size > 0;
    }

    // Marked map with the geoloc of each endpoint
    endpointIpMap.forEach((item, i) => {
        // Add the markers for each endpoints.
        var endpointMarker = L.marker([item.value.geoloc.lat, item.value.geoloc.lon]);
        endpointMarker.on('click', clickEvent => {
            var labelQuery = "SELECT DISTINCT ?label  { GRAPH ?g { ?dataset <http://rdfs.org/ns/void#sparqlEndpoint> <" + item.key + "> . { ?dataset <http://www.w3.org/2000/01/rdf-schema#label> ?label } UNION { ?dataset <http://www.w3.org/2004/02/skos/core#prefLabel> ?label } UNION { ?dataset <http://purl.org/dc/terms/title> ?label } UNION { ?dataset <http://xmlns.com/foaf/0.1/name> ?label } UNION { ?dataset <http://schema.org/name> ?label } . } }";
                sparqlQueryJSON(labelQuery, responseLabels => {
                    console.log(responseLabels);
                });
            });
            endpointMarker.addTo(map);

        });

        // Create an histogram of the SPARQLES rules passed by endpoint.
        var sparqlesCountQuery = "SELECT DISTINCT ?endpoint ?count WHERE { GRAPH ?g { ?base <http://rdfs.org/ns/void#sparqlEndpoint> ?endpoint . ?metadata <http://ns.inria.fr/kg/index#curated> ?base . ?base <http://rdfs.org/ns/void#triples> ?count } } GROUP BY ?endpoint  ORDER BY DESC( ?count) ASC(?endpoint)";
            sparqlQueryJSON(sparqlesCountQuery, json => {
                var jsonBaseCountSparqles = [];
                json.results.bindings.forEach((bindingItem, i) => {
                    jsonBaseCountSparqles.push({'endpoint': bindingItem.endpoint.value, 'count':bindingItem.count.value});
                });

                console.log(jsonBaseCountSparqles);
                var histoHtml = document.getElementById('histo');
                histoHtml.appendChild(Plot.areaY(jsonBaseCountSparqles,{y: "count"}, {x: "endpoint", fill: "#bab0ab"}).plot());
            });

            // Create an force graph with the graph linked by co-ocurrence of vocabularies
            var sparqlesVocabularies = "SELECT DISTINCT ?endpoint ?vocabulary  WHERE { ?base <http://rdfs.org/ns/void#sparqlEndpoint> ?endpoint . ?metadata <http://ns.inria.fr/kg/index#curated> ?base . ?base <http://rdfs.org/ns/void#vocabulary> ?vocabulary } GROUP BY ?endpoint";
                sparqlQueryJSON(sparqlesVocabularies, json => {
                    // Retrieval of the list of LOV vocabularies to filter the ones retrived in the index
                    var LOVVocabularies = new Set();
                    var xhr = new XMLHttpRequest();
                    xhr.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            var response = JSON.parse(this.responseText);
                            response.forEach((item, i) => {
                                LOVVocabularies.add(item.uri)
                            });



                            var gatherVocab = new Map(); // List of vocab per endpoint
                            var endpointSet = new Set();
                            var vocabSet = new Set();
                            json.results.bindings.forEach((bindingItem, i) => {
                                var vocabulariUri = bindingItem.vocabulary.value;
                                var endpointUri = bindingItem.endpoint.value;
                                if(LOVVocabularies.has(vocabulariUri)) {
                                    endpointSet.add(endpointUri);
                                    vocabSet.add(vocabulariUri);
                                    if(! gatherVocab.has(endpointUri)) {
                                        gatherVocab.set(endpointUri, new Set());
                                    }
                                    gatherVocab.get(endpointUri).add(vocabulariUri);
                                }
                            });

                            var jsonVocabLinks = new Set();
                            var jsonVocabNodes = new Set();

                            endpointSet.forEach((item, i) => {
                                jsonVocabNodes.add({'id':item, 'group':'Knowledge base', 'radius':'1'})
                            });
                            vocabSet.forEach((item, i) => {
                                jsonVocabNodes.add({'id':item, 'group':'Vocabulary', 'radius':'1'})
                            });
                            gatherVocab.forEach(( value1, key1, map1) => {
                                value1.forEach((item, i) => {
                                    jsonVocabLinks.add({'source':key1, 'target':item, 'value':1})
                                });

                            });

                            var histoHtml = document.getElementById('vocabs');
                            var chart = ForceGraph({'links':[...jsonVocabLinks], 'nodes':[...jsonVocabNodes]} , {
                                nodeId: d => d.id,
                                nodeGroup: d => d.group,
                                nodeTitle: d => `${d.id}\n${d.group}`,
                                linkStrokeWidth: l => Math.sqrt(l.value),
                                width:600,
                                height: 600
                            });

                            histoHtml.appendChild(chart);

                        }
                    }
                    xhr.open('GET', 'https://lov.linkeddata.es/dataset/lov/api/v2/vocabulary/list', true);
                    xhr.send();



                });

            </script>

        </body>
        </html>
